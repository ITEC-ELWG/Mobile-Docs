# 【Android】知识总结（I）

----

> 作者： 王远涵
时间： 2015-11-20
关键词： `线程` `性能影响因素`

---

### **主线程**

#### **概述**
当某一个应用程序启动时， Android将会启动一个`LINUX`进程及一个主线程（UI线程）， 用于分发事件给相应的`widget`、刷新UI界面并负责与UI相关的操作（控件监听、事件响应等）

#### **工作流程**
例如用户按下某一`button`控件时
1. 主线程将`touch`事件派发给`widget`
2. `widget`接收后设置为按下状态并同时向事件队列发送一个无效请求
3. 主线程将该请求弹出栈并通知`widget`重画

#### **存在问题**
若不进行任何的分配操作， 该应用程序中所有的组件都将在主线程中运行, 而这种单线程模式会使得程序非常低效。 例如在之前完成的笔记本应用中， 由于没有考虑过app性能的问题， 我只创建了一个主线程， 并将数据库的CRUD全部放在主线程中与各控件的属性交错执行。 目前由于笔记条目很少所以可能看不出影响， 但若条目非常多时， 每一次的数据库遍历等高复杂度操作都将会导致主线程产生较长时间的阻塞， 而在此期间， 主线程将不会再派发包括`drawing event`在内的事件。 这一点对于用户而言就会体现为UI不再随着用户的操作而更新， 即程序终止。 在UI阻塞约5秒后， 程序甚至会出现`ANR`（Application Not Responding）提示并被强制关闭。 由此可以看出， 单线程模式是非常不友好的

### **非主线程**
#### **概述**
在单线程模式存在的种种问题之下， 非主线程（后台线程）应运而生。 在Android的设计思想中， 为了让用户能够得到顺滑流畅的操作体验， 类似于前文提到的数据库CRUD， 以及网络访问等耗时任务是不能在UI线程中运行的， 而必须放在后台线程中进行相应的处理， 使得程序的UI能够顺畅执行

#### **特点**
- 耗时长且运行时会占用大量资源
- 部分程序可能无法得到确切的结果或返回值（例如下载网络资源等）

#### **与UI线程的交互方式**
在Android相关规定中， 除UI线程外， 其他线程都无法对程序的UI控件进行访问或执行相关操作。 后台线程与UI的交互只能够通过以下几种方式进行

1. **Handler**
`Handler`主要接收子线程发送的数据， 并对此数据进行处理， 从而实现异步更新。 `Handler`运行在主线程中， 接收子线程传过来的`Message`对象（该对象内包含子线程发送的数据）并将这些消息放入主线程队列中， 以配合主线程进行UI的更新
`post`和`sendMessage`为`Handler`中分发消息的主要方法， 其中`post`方法可将一个`Runnable`对象插入主线程队列中， 而`sendMessage`方法则会将一个带数据的`Message`对象插入队列中并等待更新

2. **Activity.runOnUIThread(Runnable)**
实现该交互方法只需要进行以下几部简单的操作， 且无需调用后台线程的`start`方法
① 编写后台线程（可以直接调用UI控件）
② 创建后台线程实例
③ 调用UI线程对应`Activity`的`runOnUIThread`方法，将后台线程实例作为参数传入

3. **View.Post(Runnable)**
该方法和上一方法类似， 区别在于后台线程中能操控的UI控件只能是指定的UI控件`View`。 操作如下
① 编写后台线程（只能直接调用`View`控件）
② 创建后台线程实例
③ 调用UI控件`View`的`post`方法， 将后台线程实例作为参数传入

4. **View.PostDelayed(Runnabe,long)**
该方法是上一方法的补充， 其中long用于实现后台线程的延时运行 

5. **Async Task**
`Async Task`（以下简称AT）是一个专门用于处理后台线程与UI线程的工具
AT拥有三个重要参数及四种重要回调方法：
|`Params`|`Progress`|`Result`|
|:--|:--|:--|
|后台线程运行时外界为其提供的必要参数|后台线程处理作业的进度|后台线程运行的结果， 即提交给UI线程的信息|
 
|`onPreExecute`|`doInBackground`|`onProgressUpdate`|`onPostExecute`|
|:--|:--|:--|:--|
|运行在UI线程， 为后台线程运行做准备， 运行完后调用`doInBackground`|运行在后台线程， 负责运行任务。 拥有参数`Params`， 返回`Result`|运行在UI线程， 负责更新UI控件， 拥有参数`Progress`|运行在UI线程， `doInBackground`运行完后， 调用该方法并传入`Result`， 进而将`Result`更新到UI控件上|

### **性能影响因素**
#### **代码**
程序整体性能的决定性因素应当是程序的逻辑设计、代码的数据结构及算法。 不管执行环境如何， 高效的代码都是必不可少的。 而代码的高效与否取决于两条准则：
- 是否执行了不必要的操作
- 是否分配了不必要的内存
具体来说可分为以下几点：
- **不必要对象的创建**  创建过多的对象将会使虚拟机运行时堆内存迅速达到上限， 进而触发GC操作， 使得所有线程暂停运行
- **循环操作的效率**  Java中不同循环的效率也是不同的， 目前而言， 最高的应当是`for-each`循环
- **数据类型**  Android设备中浮点型数据的处理速度大概比整型慢两倍左右， 因此在精度允许的条件下应当尽量减少浮点型的使用
- **库函数**  合理使用库函数实现相应功能往往比直接实现效率更高
- **算法**  复杂算法尽量采用C/C++实现， 并用JNI（Just-in-time Compilation， 即时编译）调用。 简单算法则可以直接实现， 毕竟JNI调用也会花一定的时间
#### **渲染机制**
卡顿等常见性能问题最主要的根源都是因为渲染性能。 Android系统每16ms发出VSYNC信号， 触发UI的渲染， 这意味着程序操作应当在16ms内完成。 如果某个操作花费了24ms， 系统在得到VSYNC信号时就无法进行正常渲染， 进而便会丢帧。 那么用户将会在在32ms内看到同一帧画面
#### **GC机制**
Android系统会根据内存中不同的内存数据类型执行相应的GC（Garbage Collection）操作， 而在此期间， 所有线程的所有操作都将暂停等待GC操作完成。 单个GC操作不会占用太多的时间， 但是大量不停的GC操作（通常由内存抖动、瞬间产生大量对象等引起）则会显著占用帧间隔时间(16ms)。 若在帧间隔时间里面做了过多的GC操作， 那么相应的渲染等操作的可用时间就将变得更少
#### **数据库**
数据库的CRUD操作具备很高的复杂度， 尤其对于大型数据库而言， 每一次数据库操作都将耗费大量时间和内存资源。 合理地使用索引及事务以及使用异步线程等均可在数据库层面提高系统整体性能
#### **布局**
一个系统中往往会存在多个页面， 每一次活动的跳转所导致的页面加载都是一项非常耗时的操作。 事实上， 多数系统中的页面之间往往会存在公共部分， 利用`<include>`标签将公共部分提出并模块化可在一定程度上改善系统性能。 此外， 去除不必要的嵌套、`View`节点及`inflate`等都可以在布局方面进行优化
#### **移动网络**
系统连接服务器、获取数据等操作的方式也会影响系统的整体性能。 另外， 预连接、预取数据、按优先级延迟请求、多连接等手段也可对系统进行一定程度的优化

----

> 参考资料
[1] [Google Android性能优化典范视频](https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE)
[2] [Android性能优化典范中文版](http://hukai.me/android-performance-patterns/)
[3] [Android性能调优](http://www.trinea.cn/android/android-performance-demo/)


