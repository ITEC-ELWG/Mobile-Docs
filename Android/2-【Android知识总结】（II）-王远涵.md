#【Android知识总结】（II）

----

> 作者： 王远涵  
时间： 2015-11-30  
关键词： `SQLite`　`数据库最佳实践`

----

## SQLite
### 优点
1. **轻量级：** `SQLite`和`C/S`模式的数据库不同，`SQLite`为进程内数据库引擎，嵌入运行于程序的进程空间，因此不存在数据库的客户端和服务器，运行速度更快。`SQLite`全部功能均包含在一个不到500KB的动态链接库文件中
2. **绿色软件：** `SQLite`的核心引擎不依赖任何第三方的软件，只需编译链接进程序即可，无须“安装”操作，在部署的时候能够省去许多麻烦
3. **单一文件：** `SQLite`数据库中所有信息（如表、视图、触发器等）都包含在一个文件内，类似于`Access`，数据文件拷贝及备份十分方便
4. **跨平台/可移植性：** `SQLite`除了支持主流常见的操作系统（如`Windows`、`Mac OS X`、`Linux`等），还支持很多嵌入式系统（如`Android`、`Windows` `Mobile`、`Symbin`、`Plam`、`VxWorks`等）
5. **提供多种语言接口：** `SQLite`支持`C/C++`、`Java`、`Python`、`PHP`、`DOT.NET`等多种语言，提供了多种编程接口，适合混合语言编程，允许为`SQL`命令集动态添加自定义函数（简单函数及聚集函数），而无须重新编译`SQLite`库
6. **内存型数据库：** `SQLite`具备内存数据库特性。`SQLite`的API不区分当前操作的数据库是在内存还是在文件（对于存储介质是透明的）。如果程序中磁盘I/O有成为瓶颈的可能的话，可以考虑切换为内存方式。切换时操作`SQLite`的代码无须太大改动，只须在开始时把文件`Load`到内存，结束时把内存的数据库`Dump`回文件即可

### 缺点
1. **粒度较大：** `SQLite`通过`OS`的文件锁实现库级锁，粒度很大，对并发控制、数据加密支持的不是太好，在创建索引（`CREATE INDEX`）和删除表（`DELETE TABLE`）时明显比其他数据库慢。但基于其开放源码的特性，用户可以自行就这一方面进行改进
2. **并发访问的锁机制：** `SQLite`在并发（包括多进程和多线程）读写方面的性能一直不太理想。数据库可能会被写操作独占，从而导致其他读写操作阻塞或出错
3. **标准支持不全：** `SQLite`不支持包括完全触发器支持和可写视图在内的部分`SQL92`标准
4. **网络文件系统：** 当需要访问其他机器上的`SQLite`数据库文件时，需要把数据库文件放置到网络共享目录上。而当`SQLite`文件放置在网络文件系统上时，在并发读写的情况下可能会出问题（如数据损坏等）
5. **网络服务器：** 从应用程序运行位于其他计算机上的`SQLite`的惟一方法是从网络共享运行。这样会导致一些问题，如 UNIX® 和 Windows® 网络共享都存在的文件锁定问题，以及由于与访问网络共享相关的延迟而带来的性能下降问题等
6. **用户账户概念：** `SQLite`没有用户账户概念，而是根据文件系统确定所有数据库的权限。这样会使强制执行存储额发生困难及强制执行用户许可等操作无法进行

----

## 数据库的最佳实践
### 通用
以下内容参考自[20 Database Design Best Practices](http://www.javacodegeeks.com/2012/02/20-database-design-best-practices.html)

1. 使用明确、统一的标明和列名，例如`School`，`SchoolCourse`，`CourceID`
2. 数据表名使用单数而不是复数，例如`StudentCours`，而不是`StudentCourses`
3. 数据表名不要使用空格
4. 数据表名不要使用不必要的前缀或者后缀，例如使用`School`，而不是`TblSchool`，或者`SchoolTable`等等
5. 数据库中的密码要加密，到应用中再解密（即散列存储、单向加密）
6. 使用整数作为ID字段，也许现在没有这个必要，但是将来需要，例如关联表，索引等
7. 使用整数字段做索引，否则会带来很大的性能问题
8. 使用`bit`作为布尔字段，使用整数或者`varchar`是浪费，同时，这类字段应该以`Is`开头
9. 要经过认证才能访问数据库，不要给每一个用户管理员权限
10. 尽量避免使用`select *`，而使用`select [required_column_list]`以获得更好的性能
11. 假如程序代码比较复杂，使用`ORM`框架，例如`hibernate`，`iBatis`，`ORM`框架的性能问题可以通过详细的配置去解决
12. 分割不常使用的数据表到不同的物理存储以获得更好的性能
13. 对于关键数据库，使用安全备份系统，例如集群，同步等等
14. 使用外键，非空等限制来保证数据的完整性，不要把所有的东西都扔给程序
15. 缺乏数据库文档是致命的，你应该为你的数据库设计写文档，包括触发器、存储过程和其他脚本
16. 对于经常使用的查询和大型数据表，要使用索引，数据分析工具可以帮助你决定如何建立索引
17. 数据库服务器和网页服务器应该放在不同的机器上，这将提高安全性，并减轻CPU压力
18. `Image`和`blob`字段不应该定义在常用的数据表中，否则会影响性能
19. 范式`Normalization`要按照要求使用以提高性能，`Normalization`做的不够会导致数据冗余，而过度`Normalization`会导致太多的`join`和数据表，这两种情况都会影响性能
20. 多花点时间在数据库设计上，否则将会付出加倍的时间来偿还

### SQLite
1. 将底层数据库封装起来，只公开与该数据库进行交互时必须使用的公有方法和常量，这一般会用到通常所谓的合同或辅助类，这个类应该公开数据库常量，特别是列名，填充和查询数据库时必须使用列名
2. `SQLiteOpenHelper`会在成功打开数据库实例后缓存它们，所以可以在刚好要执行查询或事务前请求打开数据库，出于相同的原因，除非不再使用数据库，否则无须手动关闭它们
3. 若磁盘空间不够或没有足够的权限，对`getWritableDatabase`的调用可能失败，因此如有必要，在需要查询数据库时应使用`getReadableDatabase`方法作为后备
4. 创建数据库后，必须处理原来在`SQLiteOpenHelper`的`onCreate`和`onUpgrade`处理程序中处理的创建和升级逻辑
5. 将数据库的创建和打开推迟到需要的时候再执行，并在成功打开数据库实例后缓存它们以限制关联的效率成本
6. 数据库的复杂操作应当异步处理，以免影响主应用程序线程的工作
7. 文件（如位图或音频文件）通常不存储在数据库的表中，应该使用一个字符串来存储文件的路径，当然，使用一个完全限定的`URI`来存储文件的路径效果会更好
8. 所有的表最好都应包含一个自动增加的键字段，作为每一行的唯一索引字段，如果计划使用`Content Provider`来共享表，就必须具有唯一的`ID`字段
9. 确保代码不会尝试在一个`SQLite`数据库中插入空的`ContentValues`对象，如果必须要在数据库中添加一个空行，那么在传入一个空的`ContentValues`对象的同时，还必须传入一个值可以显示设置为`null`的列的名称

----