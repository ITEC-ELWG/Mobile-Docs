# iOS中性能影响因素
> 创建时间：2015-11-20  
> 作者：曾祥意  
> 关键词：性能  

----------


###线程

- **主线程**: 一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”。
- **主线程的工作**：UIKIT所有的工作，显示和刷新UI界面，处理UI事件，比如点击事件、滚动事件、拖拽事件等。
- **原则**: 避免将比较耗时的操作放到主线程中。耗时操作会卡住主线程，严重影响UI的流畅度，给用户不好的体验。
- **总结**：主线程的工作都是跟UI有关，是直接跟用户交互，所以主线程不能被阻塞。当app进行I/O操作等比较耗时耗资源的操作时，要避免它们阻塞主进程，可以开启非主线程或者是使用第三方框架。以笔记本应用为例，显示刷新视图，点击进入另一个视图，这些应该放在主线程；数据库的增删改查则应该放在非主线程或者使用FMDB库。


----------


###iOS程序性能分析

- **应用首次加载**
> A: 链接和载入：可以在Time Profile中显示dyld载入库函数，库会被映射到地址空间，同时完成绑定以及静态初始化.                                             
> B: UIKit初始化：如果应用的Root View Controller是由XIB实现的，也会在启动时被初始化.                
> C: 应用回调：调用UIApplicationDeleagte的回调：application:didFinishLaunchingWithOptions.           
> D: 第一次Core Animation调用：在启动后的方法-[UIApplication _resportAppLaunchFinished]中调用CA::Transaction::commit实现第一帧画面的绘制.

 应用程序首次加载中启动方法willFinishLaunchingWithOptions和didFinishLaunchingWithOptions只做应用程序首次启动必须的要操作,  不必要的Framework不要链接，避免首次加载耗时。

- **viewWillAppear**
viewWillAppear在 view 显示之前被调用，出于效率考虑，在这个方法中不要处理复杂费时的事情；只应该在这个方法设置 view 的显示属性之类的简单事情，比如背景色，字体等。不然，用户会明显感觉到 view 显示迟钝.

- **加载图片**
图片的初始化有两种方式：
> A：imagedNamed初始化
> B：imageWithContentsOfFile初始化

 二者不同之处在于, imageNamed默认加载图片成功后会内存中缓存图片, 这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象.如果缓存中没有找到相应的图片对象, 则从指定地方加载图片然后缓存对象，并返回这个图片对象。而imageWithContentsOfFile则仅只加载图片,不缓存。大量使用imageNamed方式会在不需要缓存的地方额外增加开销CPU的时间来做这件事.当应用程序需要加载一张比较大的图片并且使用一次性，那么其实是没有必要去缓存这个图片，用imageWithContentsOfFile是最为经济的方式,这样不会因为UIImage元素较多情况下，CPU会被逐个分散在不必要缓存上浪费过多时间。

- **图片尺寸**
图片尺寸的缩放是很耗时的，因此事先调整好图片的尺寸很重要。

- **ARC管理内存**
ARC可以帮助避免内存泄露，对象不再使用时立马被回收来提高性能，工程中要多使用ARC。
**注意**：ARC只能避免大部分内存泄露，不能消除所有的内存泄露。

- **NSDateFormatter初始化**
 
 > NSDateFormatter对象本身初始化很慢,同样还有NSCalendar也是如此.然而在一些使用场景中不可避免要使用他们,比如Json数据解析中.使用这个对象同时避免其性能开销带来性能开销,一般比较好的方式是通过添加属性(推荐)或创建静态变量保持该对象只被初始化一次，而被多次复用。不得不值得一提的是设置一个NSDateFormatter属性速度差不多是和创建新的实例对象一样慢。
 
 针对NSDateFormatter时间开销除了重用对象外，尽量避免采用其处理多个日期格式。针对日期格式处理如果需要提高更多速度，可以直接采用C, 可以采用第三方库来规避这个问题。还可以使用 Unix timestamps，可以把时间戳转换成NSDate：
 

	    (NSDate*)dateFromUnixTimestamp:(NSTimeInterval)timestamp {
		    return [NSDate dateWithTimeIntervalSince1970:timestamp]; 
	    }


- **reuseIdentifier**
 使用UITableViewCells时，当记录有很多，需要很多表格行时，如果对每条记录都创建相应的UITableViewCells对象，会消耗大量内存资源。在UITableViewCells中设置重用标识，用户滚动UITableView对象时，移出去的UITableViewCells就会放在对象池，等待重用，提高了性能。

- **XIB文件**
加载XIB到内存时，所有的内容都会载入内存，对于一些不是立即使用的视图而言，这就浪费了内存。所以尽量为一个视图控制器创建一个XIB，如果可能的话，把一个视图控制器的视图分层管理在单独的XIB中。
**注意**：storyboard只会在需要的时候实例化一个视图控制器。

- **延迟加载视图**
当应用有很多视图时，不要一次性创建所有的视图，而是在需要的时候再去创建，并把它们加入到重用队列。
**注意**：需要的时候再创建视图也有确定，比如用户点击button的时候，不能够快速地响应。

- **不透明视图**
尽可能设置视图为不透明，即opaque属性设置为YES，关于opaque：
>这个属性提供了一个提示给图系统如何对待这个视图。如果设置为YES，绘制系统将会把这个视图视为完全不透明。这样允许系统优化一些绘制操作和提高性能。如果设置为NO，绘图系统会复合这个视图和其他的内容，这个属性的默认值是YES

- **缓存**
缓存可以避免开辟新的内存，快速访问数据。缓存不经常改变却经常被使用的数据，比如缓存图片，table视图的行高等，可以提升运行速度。

- **数据的格式**
需要从服务器上获取数据的时候，尽量保证请求的数据和接收的数据格式一致，这样就可以减少甚至避免数据的操作，在内存中操作数据非常消耗资源。
**注意**：小规模数据用JSON格式，大规模的数据用XML格式

